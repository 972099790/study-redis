# REDIS使用场景

## 消息队列
	消息队列一般是为了吧瞬间的服务器请求转为异步处理。缓解服务器的压力。

	也实现了应用的解耦。让不同的功能专心做一个事情。

	队列当然也实现了顺序的获取功能。

	还有重要的流量削峰功能。运用list类型。

	一般实现步骤：

	1-队列：rpush（从右边插入）.lpop（从左边出队）
	2-建立定时任务入队
	3-建立定时任务出队

## 商品维度计数
	对商品的喜欢数，评论数，浏览数等计数。

	运用redis的hash类型即可。

	#id123的商品，喜欢次数有5次：
	#$redis->hset('product:123','like_num',5);

	#id123商品的喜欢数加1：
	$redis->hIncBy('product:123','like_num',1);

	#id123商品的评论数有10个：
	$redis->hset('product:123','comments',10);

	#获取id123商品的相关信息：
	$redis->hGetAll('product:123');

	#得到一个数组。包含喜欢评论等。

## 用户维度计数

	对用户动态关注粉丝等等计数。

	也是运用hash类型。格式和商品维度差不多。

## 存储社交关系

	社交关系是互相交叉的。

	可以用zset类型求交集。同时还支持排序。

	$redis->zAdd();

	$redis->zInter(新交集,array(交集1，交集2));

	#获取全部的集合：

	$redis->zRange();

## 缓存

	缓存的话用到字符串类型即可。

	可以作用到商品列表，评论列表，提示列表。
	还有期限缓存：用在购物车等。

	保留用户的访问记录。一般需要设置一个有效期。

## 最新列表&排行榜

	利用redis的zset类型。就能做成最新列表。

	利用录入商品的时间戳作为分数即可。

## 消息通知

	用hash结构即可。设置未读消息和未读评论。

	#设置1条未读系统消息
	$redis->hSet('user:1000:message:notice', 'system', 1);

	#设置1条未读评论
	$redis->hSet('user:1000:message:notice', 'comment', 1);

	#查看所有消息通知数量
	$redis->hGetAll('user:1000:message:notice');

## 数据统计

	如统计每次访问的独立ip数量：

	应当使用redis的hyperloglog：

	该结构是可以估算出元素的基数(不相同的个数)。

	需要注意的是不能返回输入的元素。只能返回估算值

	/*hyperloglog*/

	#添加元素:只能接受两个参数，多个元素用数组。
	#返回结果：如果基数值发生改变就是1.否则0.
	$l = $redis->pfadd('alone',array('zhangsan','lisi','wangwu'));

	#返回基数估算值
	$l = $redis->pfcount('alone');

	#如果是多个hyperloglog，会并集处理。
	$l = $redis->pfadd('alone1',array('zhangsan1','lisi1','wangwu'));
	#合并也是只能传入两个参数
	$l = $redis->pfmerge('al',array('alone','alone1'));
	#测试结果
	$l = $redis->pfcount('al'); // int(5)

## 防止缓存击穿
	
#### 什么是缓存击穿

	当服务器设置了缓存以后，

	如果黑客用根本不存在的数据去请求服务器。

	缓存里一定是没有的，就只能从数据库里去取。拿到数据以后再缓存.

	这些是不必要的缓存。数据量巨大。

	造成许多无用缓存，甚至导致数据库崩溃。

#### 什么是布隆过滤器

> 布隆过滤器能很迅速的判断一个元素是否存在一个集合中。
> 如果判断不在集合中。
> 可以提前就返回能避免后面的昂贵操作。如访问db，数据写入缓存等。
> 因此布隆过滤器必须要足够的迅速，同时要保证消耗不高。
> 布隆过滤器采用了概率型的数据结构。

	实现原理：

	1-首先是提供一个bit数组。值只有0和1.
	2-如果想映射一个值到布隆中，需要使用到不同的哈希函数去生成多个不同的哈希值。
	3-将生成的多个哈希值指向的bit位置的值变成1(默认都是0)
	4-这样一个值映射过来，就可以在很多人不同的位置置为了1.
	5-由于不同的值，在不同的哈希函数中可能会在某一个bit位置同时生成。
	6-所以是概率判断：如果一个值，通过不同的哈希得到不同值以后
	7-只要有一个值的bit位不是1，那一定不存在。
	8-但该值的全部哈希bit位都是1，却不能说明该值存在(这可能是由其他很多的值通过不同哈希函数生成位置替换上去的)
	9-这也看出。越大的数组，越多的哈希函数处理，误判率越低。
	10-由于可以重叠的原因。布隆是不允许删除值的。

#### 使用布隆过滤器

	布隆过滤器本来是作为redis的一个插件。

	官方地址：https://github.com/RedisLabsModules/redisbloom/

	添加多个ip到ips
	bf.add ips '127.0.0.1'
	...

	判断某ip是否存在
	bf.exists ips '11.1.2.25'


	也可以用redis自身的setbit和getbit实现过滤器功能。

	setbit对指定偏移量上的位进行设置为0或者1.

	当在拉伸的时候，空白的位置都是0来填充的。最大的偏移量是2^32.

	bit映射限制是512MB.

	为了方便理解原理。这里着重编写自己构造的过滤器。

> 代码 -- 

```php
	<?php 

	$redis = new \Redis();
	$redis->connect('127.0.0.1',6379);

	#几个哈希函数处理值。得到几个位置10,110.
	#分别将位置的值设置为1.
	$l =$redis->setbit('ips',10,1);
	$l =$redis->setbit('ips',110,1);

	#判断值的时候，先哈希拿到位置，根据位置查看是否为0
	$l =$redis->getbit('ips',1);
```

## 商品秒杀

	redis支持事务。一个事物就是一个队列缓存。

	当执行此事务的时候，其他事务无法插入到本事务。

	事务收到执行后，执行事务内容。

	但是遇到错误不会终止执行。其他正确的命令依然会继续执行。

	由于此特性，引入redis的watch命令。

	该命令是监控某一个值。如果监控的值改变，则事务会失败。

	很明显这是一个乐观锁的实现机制。

	将版本号取出来watch监视。

	然后开启事务。执行事务。

	如果有其他的修改导致了版本号改变。

	那事务会中断。

